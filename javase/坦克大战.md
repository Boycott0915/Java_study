# 坦克大战

## 绘制子弹

1.定义一个shot.class类实现runnable以保证线程安全

​	子弹各个参数x  y  direction  speed定义

​	子弹消亡问题 超出边界时要取消当前进程

2.在hero类中实现shotEnemyTank方法

​	要new shot=null

​	根据坦克位置 确定子弹的x y direction

3.hero按下j键后 就发射子弹

4.利用myPanel绘制出子弹

## 绘制敌军坦克

1.在敌人坦克类，使用Vector数组保存多个Shot

2.每当new一个敌人坦克对象时，给敌人坦克初始化一个Shot对象，同时启动Shot(因为Shot是多线程)

3.在绘制敌人坦克时，需要遍历敌人坦克对象里的Vector数组，绘制所有的坦克，当子弹isAlive==false时，就从Vector移除

## 当子弹打中敌军 敌军坦克消失

1.在myPanel类中编写方法判断子弹是否击中敌军坦克

​	public static void hitTank(Shot bullet,Enemy enemy){

}

2.在run方法中判断子弹什么时候击中敌军坦克

​	子弹活着？

​		遍历所有坦克 调用hitTank方法判断是否击中

3.修改paint中对敌人坦克的描绘 需要判断敌人坦克是否存活

4.解决坦克击中敌人，但是子弹仍然没有消亡的问题(在shot中修改子弹灭亡条件即可)

## 让坦克消失时 出现爆炸效果

1.定义一个Bomb类  x y life(生命周期 记录是否消亡) isAlive=true

​	定义lifeDown()方法 用来减少生命值

```java
package draw.tankwar;

public class Bomb {
    int x;
    int y;
    int life = 9;
    Boolean isAlive = true;

    public Bomb(int x, int y) {
        this.x = x;
        this.y = y;
    }

    //定义lifeDown()减少生命值
    public void lifeDown() {
        if (life > 0) {
            life--;
        } else {
            isAlive = false;
        }
    }
}

```

2.由于爆炸效果是在Panel上出现 所以写在Panel上

​	定义一个Vector<Bomb>bombs用于存放炸弹

```java
    //定义一个Vector<Bomb>数组 用来存储炸弹
    static Vector<Bomb> bombs = new Vector<>();

```

​	定义三张炸弹图片 用于显示爆炸效果

```java
    //定义三张图片 用于显示爆炸
    Image image1 = null;
    Image image2 = null;
    Image image3 = null;
    
```

​	在构造器中加载 初始化图片对象 

```JAVA
//在public MyPanel() 下初始化图片对象
        image1=Toolkit.getDefaultToolkit().getImage("C:\\Users\\Easson\\IdeaProjects\\TankWar\\images\\bomb_1.gif");
        image2=Toolkit.getDefaultToolkit().getImage("C:\\Users\\Easson\\IdeaProjects\\TankWar\\images\\bomb_2.gif");
        image3=Toolkit.getDefaultToolkit().getImage("C:\\Users\\Easson\\IdeaProjects\\TankWar\\images\\bomb_3.gif");

```

3.当子弹击中坦克时 就加入一个Bomb对象到Bombs数组中(在Mypanel类的hitTank下执行) 

```java
                    //在hitTank这里添加爆炸效果Bomb
                    Bomb bomb = new Bomb(enemy.getX(), enemy.getY());
                    bombs.add(bomb);
```

4.在paint中绘画

​	if(集合中有炸弹)

```java
for (int i = 0; i < bombs.size(); i++) {
            Bomb bomb = bombs.get(i);
            if(bomb.life>6){
                g.drawImage(image1,bomb.x,bomb.y,60,60,this);
            }else if(bomb.life>3){
                g.drawImage(image2,bomb.x,bomb.y,60,60,this);
            }else{
                g.drawImage(image3,bomb.x,bomb.y,60,60,this);
            }
            //每次都要减少一次寿命
            bomb.lifeDown();
            //如果bomb.life=0 bomb消失
            if(!bomb.isAlive){
                bombs.remove(bomb);
            }
        }
```

问题：

1.敌军坦克消失后 子弹射出 仍然会产生爆炸效果

​	原因:子弹默认那个位置还有坦克 所以穿不过去

​		敌人坦克爆炸以后 我们没有从vector enemyTank中将敌人坦克拿掉

​		解决方法：将hitTank设置成boolean 如果击中就设为true 然后在enemies中将被击中的坦克remove   之前我们只是将被击中的enemy的isAlive设置为false，并没有将它从对象中拿走，这样子只能让画板不描绘出来，但不能阻止它隐形存在，所以子弹击中仍然有爆炸效果	

2.我方坦克能走出边界(不合理)

## 让敌军的坦克能自由随机移动

参考我方坦克移动

每次random(0,3) 之间 然后在按键操作 ==》(int)(Math.random()*4)–> 可以取到[0,4) 的整数 即0，1，2，3

要求：1.将敌人坦克当作线程使用  需要将Enemy实现Runnable

​	   2.在run方法中实现方法

​		移动

​		退出

```java
    public void run() {
        while (true){
            //根据坦克的方向来继续移动
            switch (getDir()){
                case 0://向上
                    for (int i = 0; i < 10; i++) {
                        moveUP();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    break;
                case 1://向右
                    for (int i = 0; i < 10; i++) {
                        moveRight();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    break;
                case 2://向下
                    for (int i = 0; i < 10; i++) {
                        moveDown();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    break;
                case 3://向左
                    for (int i = 0; i < 10; i++) {
                        moveLeft();
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                     break;
            }
            //然后随机改变坦克的方向
            setDir((int)(Math.random()*4));
            //子弹什么时候退出线程
            if(!isAlive){
                break;//退出线程
            }
        }
    }
```

​	3.在创建敌人坦克对象时启动线程(Mypanel)

```JAVA
            //设置敌军的位置
            Enemy enemy = new Enemy(100 * (i + 1), 0);
            //开启敌军坦克线程
            new Thread(enemy).start();
```

## 控制我方坦克和敌人坦克在规定的范围移动

1.在Enemy中移动方向那片代码增加条件判断

```java
case 0://向上
                    for (int i = 0; i < 10; i++) {
                        if (getY()-getSpeed()>= 0){
                            moveUP();
                        }
                            try {
                                Thread.sleep(50);
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                    }
                    break;
                case 1://向右
                    for (int i = 0; i < 10; i++) {
                        if (getX() + 60+getSpeed()< 1000) {
                            moveRight();
                            try {
                                Thread.sleep(50);
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                    break;
                case 2://向下
                    for (int i = 0; i < 10; i++) {
                        if ((getY() +60+getSpeed()) <= 750) {
                            moveDown();
                            try {
                                Thread.sleep(50);
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                    break;
                case 3://向左
                    for (int i = 0; i < 10; i++) {
                        if (getX()-getSpeed() >= 0) {
                            moveLeft();
                            try {
                                Thread.sleep(50);
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                    break;
```

2.控制我方坦克

```java
public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {
            //向上运动
            if(hero.getY()>0){
                hero.setDir(0);
                hero.moveUP();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            //向下运动
            if(hero.getY()+60<750){
                hero.setDir(2);
                hero.moveDown();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            //向右运动
            if(hero.getX()+60<1000){
                hero.setDir(1);
                hero.moveRight();
            }
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            //向左运动
            if(hero.getX()>0){
                hero.setDir(3);
                hero.moveLeft();
            }
        }
        //如果用户按下J 发出子弹
        if (e.getKeyCode() == KeyEvent.VK_J) {
            hero.shotEnemyTank();
        }
    }
```

## 我方坦克只有当前子弹消亡才能发射新的子弹

1.按下J键时 先判断当前子弹是否消亡

​	yes->继续发射

​	no->不触发hero.shotEnemyTank();

```java
        //如果用户按下J 发出子弹
        if (e.getKeyCode() == KeyEvent.VK_J) {
            if(hero.shot==null||!hero.shot.isalive){
                hero.shotEnemyTank();
            }
        }
```

## 我方坦克可以多发子弹，且控制面板最多只有5颗

1.在Hero类中使用Vector集合保存

```java
    Vector<Shot>shots=new Vector<>();

shots.add(shot);
```

2.在绘制子弹时候 需要变成遍历Vector集合

```java
在hero类进行操作
Vector<Shot>shots=new Vector<>();
```

3.如何设置每次最多发射5颗子弹

```java
        if(shots.size()>=5){
            return ;
        }
```

4.hitEnemy的时候也要进行修改 因为之前是只进行一颗子弹与tank进行判断

​	如果不修改，则可能出现子弹打中tank，但是会直接穿过的现象

```java
if (hero.shot != null && hero.shot.isalive) {
                //遍历所有坦克
                for (int i = 0; i < enemies.size(); i++) {
                    Enemy enemy = enemies.get(i);
                    for (int j = 0; j < hero.shots.size(); j++) {
                        if(hitTank(hero.shots.get(j), enemy)){
                            enemies.remove(enemy);
                            hero.shots.remove(hero.shots.get(j));
                        }
                    }
                }
            }
```

## 让敌人坦克子弹消亡后 就可以继续发射子弹

设置一个while(true)？

```java
   在Enemy类的run方法中实现
   //这里判断坦克是否活着
            //再判断当前子弹是否消亡
            //如果shots.size()=0 则创建一颗子弹 放入到shots集合 并启动
            if (isAlive && shots.size() == 0) {
                //开始添加shot子弹
                Shot s=null;
                switch (getDir()){
                    //根据方向 创建子弹
                    case 0://向上
                        s = new Shot(getX() + 25, getY(), getDir());
                        break;
                    case 1://向右
                        s = new Shot(getX() + 60, getY()+25, getDir());
                        break;
                    case 2://向下
                        s=new Shot(getX()+25,getY()+60,getDir());
                        break;
                    case 3://向左
                        s=new Shot(getX(),getY()+25,getDir());
                        break;
                }
                shots.add(s);
                new Thread(s).start();
            }
```

## 敌人如果发射多颗子弹？2颗

只需要将上述的if (isAlive && shots.size() == 0)修改为if (isAlive && shots.size() <= 2)即可

```java
   在Enemy类的run方法中实现
if (isAlive && shots.size() <= 2)
```

## 当敌人坦克子弹打中我方坦克 我方坦克爆炸

1.先看看我方坦克打中地方坦克的爆炸代码

```java
//Mypanel下的hitTank方法
public static boolean hitTank(Shot bullet, Enemy enemy) {
```

想法：多态方式改变 （利用多态）

```java
public static boolean hitTank(Shot bullet, Tank tank) {
```

老韩讲解：

1.在Mypanel编写方法 判断敌军是否击中我方坦克

public void hitHero(){}

​	for 遍历所有的敌方坦克

​		for遍历坦克的所有子弹

​			取出每一个子弹

​				判断坦克存活？&&敌方子弹存活

​					hitTank(Shot bullet,Tank enemy)//这样子即可

```java
public void hitHero() {
        //遍历所以敌军坦克
        for (int i = 0; i < enemies.size(); i++) {
            Enemy enemy = enemies.get(i);
            //遍历所有子弹
            for (int j = 0; j < enemy.shots.size(); j++) {
                //每一颗子弹
                Shot shot = enemy.shots.get(j);
                if (hero.isAlive && shot.isalive&&hitTank(shot,hero)) {
                    //hitTank(shot, hero);
                    hero.isAlive=false;
                }
            }
        }
    }
```

2.在run方法中判断 是否被敌人坦克击中

```java
            //判断敌方子弹是否击中我军
            hitHero();

```

##  解决我方幽灵坦克的问题——被敌人击败爆炸后仍然能走动且发动子弹

解决走动问题和发子弹问题 在keyPress那边设置 加一个前提判断即可

```java
public void keyPressed(KeyEvent e) {
        if (!hero.isAlive){
            System.out.println("您已阵亡！！！");
            return ;
        }
}
```

## 防止敌方坦克运动重叠碰撞		

1.参考我方子弹击中敌方坦克的代码

```java
public static boolean hitTank(Shot bullet, Tank enemy) {
        //判断bullet是否击中
        switch (enemy.getDir()) {
            case 0://上
            case 2://下  上和下子弹杀死坦克的条件是一样的
                if (bullet.x > enemy.getX() && bullet.x < enemy.getX() + 50 &&
                        bullet.y > enemy.getY() && bullet.y < enemy.getY() + 60) {
                    //进入坦克体内 子弹消亡
                    bullet.isalive = false;
                    //在hitTank这里添加爆炸效果Bomb
                    Bomb bomb = new Bomb(enemy.getX(), enemy.getY());
                    bombs.add(bomb);
                    enemy.isAlive = false;
                    return true;
                }
                //break;
            case 1://右
            case 3://左
                if (bullet.x > enemy.getX() && bullet.x < enemy.getX() + 60 &&
                        bullet.y > enemy.getY() && bullet.y < enemy.getY() + 50) {
                    //进入坦克体内 子弹消亡
                    bullet.isalive = false;
                    enemy.isAlive = false;
                    //在hitTank这里添加爆炸效果Bomb
                    Bomb bomb = new Bomb(enemy.getX(), enemy.getY());
                    bombs.add(bomb);
                    return true;
                }
                //break;

        }
        return false;
    }
```

如何判断矩形相交⭐⭐

![image.png](https://i-blog.csdnimg.cn/blog_migrate/8ba461adfa3ce9abe53e14dae1e7d281.png)

## 解决矩形相交问题

```java
public boolean conflict(Enemy enemytank) {
        //for循环遍历所有tank
        for (int i = 0; i < enemies.size(); i++) {
            Enemy enemy = enemies.get(i);
            //自己碰到自己 直接跳过 但不应该是break break会终止全部循环
            //应该continue
            if (enemy == enemytank) {
//                break;
                continue;
            }
            //获得当前enemytank的方向 来判断碰撞范围
            int mydir = enemytank.getDir();
            int enemydir = enemy.getDir();

            //获取enemyTank的坐标 (x1 y1) (x2 y2)
            int x1 = enemytank.getX();
            int y1 = enemytank.getY();
            int x2 = ((mydir == 0) || (mydir == 2)) ? 50 + x1 : 60 + x1;
            int y2 = ((mydir == 0) || (mydir == 2)) ? y1 + 60 : y1 + 50;

            //获取enemy的坐标 (x3 y3) (x4 y4)
            int x3 = enemy.getX();
            int y3 = enemy.getY();
            int x4 = ((mydir == 0) || (mydir == 2)) ? 50 + x3 : 60 + x3;
            int y4 = ((mydir == 0) || (mydir == 2)) ? y3 + 60 : y3 + 50;

            //判断是否相交
            //如果相交就true 不相交就返false
            //(x1<x3||x4<x1||y1<y4||y3>y2)满足这个条件 则不相交
            //取反则相交
            if (!(x2 < x3 || x4 < x1 || y1 > y4 || y3 > y2)) {
                return true;
            }
        }
        //不相交
        return false;
    }
```

## 解决不同类的数据共享问题

```java
//新增一个enemytanks用来保存敌方坦克群 也是为了运用MyPanel中的
    // Vector<Enemy> enemies = new Vector<>();
    Vector<Enemy> enemiesTank = new Vector<>();
    //这个set方法可以使Eemy类也能使用到MyPanel类中的enemies属性
    public void setEnemiesTank(Vector<Enemy> enemiesTank) {
        this.enemiesTank = enemiesTank;
    }

// 2. 【关键步骤】为每一个敌方坦克设置它们所能感知到的全体坦克集合
        for (Enemy enemy : enemies) {
            enemy.setEnemiesTank(enemies); // 将同一个 enemies 集合的引用传递给每一个坦克
        }
```

## 正式解决坦克运动重叠碰撞

```java
/新增一个enemytanks用来保存敌方坦克群 也是为了运用MyPanel中的
    // Vector<Enemy> enemies = new Vector<>();
    Vector<Enemy> enemiesTank = new Vector<>();
    //这个set方法可以使Eemy类也能使用到MyPanel类中的enemies属性
    public void setEnemiesTank(Vector<Enemy> enemiesTank) {
        this.enemiesTank = enemiesTank;
    }
    //编写方法 判断当前坦克是否与enemiesTank发生碰撞
    public boolean conflict() {
        //for循环遍历所有tank
        for (int i = 0; i < enemiesTank.size(); i++) {
            Enemy enemy = enemiesTank.get(i);
            //自己碰到自己 直接跳过 但不应该是break break会终止全部循环
            //应该continue
            if ((enemy.getX() == getX())&&(enemy.getY()==getY())) {//说明两个坦克是一个对象
//                break;
                continue;
            }
            //获得当前enemytank的方向 来判断碰撞范围
            int mydir=getDir();
            int enemydir = enemy.getDir();

            //获取enemyTank的坐标 (x1 y1) (x2 y2)
            int x1 = getX();
            int y1 = getY();
            int x2 = ((mydir == 0) || (mydir == 2)) ? 50 + x1 : 60 + x1;
            int y2 = ((mydir == 0) || (mydir == 2)) ? y1 + 60 : y1 + 50;

            //获取enemy的坐标 (x3 y3) (x4 y4)
            int x3 = enemy.getX();
            int y3 = enemy.getY();
            int x4 = ((mydir == 0) || (mydir == 2)) ? 50 + x3 : 60 + x3;
            int y4 = ((mydir == 0) || (mydir == 2)) ? y3 + 60 : y3 + 50;

            //判断是否相交
            //如果相交就true 不相交就返false
            //(x1<x3||x4<x1||y1<y4||y3>y2)满足这个条件 则不相交
            //取反则相交
            if (!(x2 < x3 || x4 < x1 || y1 > y4 || y3 > y2)) {
                return true;
            }
        }
        //不相交
        return false;
    }

```

//开始判断

```java
//根据坦克的方向来继续移动
            switch (getDir()) {
                case 0://向上
                    for (int i = 0; i < 10; i++) {
                        if ((getY() - getSpeed() >= 0)&&!conflict()) {
                            moveUP();
                        }
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    break;
```

## 记录玩家成绩 全盘退出(IO流)

1.在myPanel下写一个showInfo在画板实时展示我方击毁的坦克

​	public void showInfo(){

​		设置画笔颜色

​		设置字体

​		将内容描绘出来(我方击毁敌方坦克)

​		再画个敌方坦克 x  击毁数量	

​	} 

```java
    //在界面上写一个showInfo用来记录玩家击毁敌方坦克数量
    public void showInfo(Graphics g) {
        g.setColor(Color.BLACK);
        g.setFont(new Font("宋体", Font.BOLD, 25));
        g.drawString("您累计击败的敌方坦克数量", 1020, 30);
        //描绘敌方坦克
        drawTank(1020,60,g,0,1);
        //还需描绘数量
        g.setColor(Color.BLACK);
        g.drawString("0",1100,100);
    }
```

2.记录Recorder类 该类用来记录我方击毁敌方坦克数

```java
package draw.tankwar;

import java.io.BufferedWriter;
import java.io.FileWriter;

public class Recorder {
    //用来保存和记录我方击毁敌方坦克数
    private static int termination_tank=0;

    //用io流记录每次数据结果
    String file="data.txt";

    public static int getTermination_tank() {
        return termination_tank;
    }
//
    public static void setTermination_tank(int termination_tank) {
        Recorder.termination_tank = termination_tank;
    }

    //设置一个方法来增加计数 每击毁一个tank termination_tank++

    public static void add_tank_nums(){
        Recorder.termination_tank++;
    }

}

```

3.当游戏结束，将数据写入到文件(IO)

```java
    // 编写方法将数据存入data.txt文档
    // 当用户exit时调用该方法
    public static void record_data(){
        //如果不写static 只有在创建实例的时候才会初始化bw
        {
            try {
                bw = new BufferedWriter(new FileWriter(file));
                bw.write(getTermination_tank()+"");
                bw.newLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }finally {
                try {
                    bw.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }


```

## 记录退出时敌人坦克坐标/方向，存盘退出

在data.txt记录 

每一行代表一个坦克数据 100 200 0

```java
//遍历敌人坦克的Vector，然后根据情况(存活或者死亡)保存即可
                //从OOP的思想 定义一个属性 通过setxxx得到 敌人坦克的Vector
                static Vector<Enemy>enemyVector=new Vector<>();

    public static void setEnemyVector(Vector<Enemy> enemyVector) {
        Recorder.enemyVector = enemyVector;
    }
            Recorder.setEnemyVector(enemies);

```

## 玩游戏时选择 开新游戏还是继续上局游戏

1.将每个敌人信息(String)恢复成Node对象=》然后用Vector数组数组

```java
 //定义一个Node的Vector 用来保存敌人信息
    static Vector<Node>nodes=new Vector<>();
    
    //增加一个方法 用于读取文件 恢复相关信息
    public static Vector<Node> getdata(){
        try {
            //br读取文件
            br=new BufferedReader(new FileReader(file));
            //首先读取的第一行是击败的敌人数量
            termination_tank= Integer.parseInt(br.readLine());
            //接下来读取的每行都是坦克的x y dir信息
            String line="";
//            //还有信息就读取信息
            while((line=br.readLine())!=null){
                String[] xydir = line.split(" ");
                Node node = new Node(Integer.parseInt(xydir[0]), 
                        Integer.parseInt(xydir[1]),
                        Integer.parseInt(xydir[2]));
                nodes.add(node);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }finally {
            if(br!=null){
                try {
                    br.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        return nodes;
    }

```

2.通过Node的Vector去恢复敌人的坦克位置和方向

在Mypanel中操作

```java
        //选择是1.恢复上局 2.重新开始
        //得到上局的数据
        nodes=Recorder.getdata();
        switch (key){
            case "0"://恢复上局
                //创建敌人位置向量
                for (int i = 0; i < nodes.size(); i++) {
                    //设置敌军的位置
                    Node node = nodes.get(i);
                    Enemy enemy = new Enemy(node.getX(),node.getY());
                    //开启敌军坦克线程
                    new Thread(enemy).start();
                    //设置方向
                    enemy.setDir(node.getDir());
                    //设置速度
                    enemy.setSpeed(2);
                    // 给enemy加子弹
                    Shot shot = new Shot(enemy.getX() + 20, enemy.getY() + 60, enemy.getDir());
                    //加入到enemy的Vector中
                    enemy.shots.add(shot);
                    //启动shot对象
                    new Thread(shot).start();
                    enemies.add(enemy);
                }
                break;
            case "1"://重新开始
                //创建敌人位置向量
                for (int i = 0; i < enemySize; i++) {
                    //设置敌军的位置
                    Enemy enemy = new Enemy(100 * (i + 1), 0);
                    //开启敌军坦克线程
                    new Thread(enemy).start();
                    //设置方向
                    enemy.setDir(2);
                    //设置速度
                    enemy.setSpeed(2);
                    // 给enemy加子弹
                    Shot shot = new Shot(enemy.getX() + 20, enemy.getY() + 60, enemy.getDir());
                    //加入到enemy的Vector中
                    enemy.shots.add(shot);
                    //启动shot对象
                    new Thread(shot).start();
                    enemies.add(enemy);
                }
                break;
            default:
                System.out.println("输入有误！！！");
        }
```

## 游戏开始时播放音乐

